// Imports ----------------------------
const sequelize = require('sequelize')
const express = require('express');
const { Op } = require('sequelize');
const bcrypt = require('bcryptjs');

const { setTokenCookie, restoreUser, requireAuth } = require('../../utils/auth');
const { Spot, SpotImage, Review, ReviewImage, User, SpotReview, Booking } = require('../../db/models');

const { check } = require('express-validator');
const { handleValidationErrors } = require('../../utils/validation');

const router = express.Router();


//-----------------------------------------------------------

/* Get all of the Current User's Bookings
Return all the bookings that the current user has made.

Require Authentication: true */


router.get('/current', requireAuth, async (req, res, nest) => {

    const user = req.user.id

    const allBookings = await Booking.findAll({
        where: {
            userId: user
        },
        include: [
            {
                model: Spot,
                attributes: [
                    'id',
                    'ownerId',
                    'address',
                    'city',
                    'state',
                    'country',
                    'lat',
                    'lng',
                    'name',
                    'price'
                ],
                include: [
                    {
                        model: SpotImage,
                        attributes: ['url'],
                        where: {preview: true},
                        limit: 1
                    }

                ]
            },
        ],
        group: ['Booking.id', 'Spot.id']
    })


    const formattedResponse = {
        Bookings: []
    }

    allBookings.forEach(element => {

        if(element.dataValues && element.dataValues.Spot.dataValues && element.dataValues.Spot.dataValues.SpotImages[0].dataValues.url){
            element.dataValues.Spot.dataValues.previewImage = element.dataValues.Spot.dataValues.SpotImages[0].dataValues.url
            delete element.dataValues.Spot.dataValues.SpotImages
        }else {
            
        }
    });

    formattedResponse.Bookings = [...allBookings]

    res.json(formattedResponse)

})

//--------------------------------------------------------------

/* Edit a Booking
Update and return an existing booking.

Require Authentication: true

Require proper authorization: Booking must belong to the current user */


router.put('/:bookingId', requireAuth, async (req, res, next) => {

    const bookingId = req.params.bookingId
    const userId = req.user.id
    let { startDate, endDate } = req.body

    const currentDate = new Date()

    const bookingOwner = await Booking.findByPk(bookingId)

    //console.log(bookingOwner)

    if(!bookingOwner){
        res.status(404).json({
            "message": "Booking couldn't be found"
          })
    }

    if(bookingOwner.dataValues.userId != userId){
        return res.status(403).json({
            "message": "Forbidden"
          })
    }

   // const bookingOwnerId = bookingOwner.dataValues.userId

    if(bookingOwner){
        const bookingEndDate = new Date(bookingOwner.dataValues.endDate)
        let todaysDate = new Date()
        //todaysDate = todaysDate.toISOString().substring(0, 10)

        if(bookingEndDate < todaysDate){
            return res.status(403).json({
                "message": "Past bookings can't be modified"
              })
        }
    }

    const checkAvailability = await Booking.findAll({
        where: {
            [Op.or]: [
              {
                [Op.and]: [
                  { startDate: { [Op.lte]: startDate } },
                  { endDate: { [Op.gte]: startDate } },
                  { id: {[Op.ne]: bookingId } }

                ],
              },
              {
                [Op.and]: [
                  { startDate: { [Op.lte]: endDate } },
                  { endDate: { [Op.gte]: endDate } },
                  { id: {[Op.ne]: bookingId } }
                ],
              },
              {
                [Op.and]: [
                  { startDate: { [Op.gte]: startDate } },
                  { endDate: { [Op.lte]: endDate } },
                  { id: {[Op.ne]: bookingId } }
                ],
              },
            ],
          }
    })

    if(startDate < currentDate || startDate === endDate || new Date(startDate) < currentDate){

        return res.status(400).json(
            {
                "message": "Bad Request",
                "errors": {
                    "startDate": "startDate cannot be in the past or the same date as the end date"
                }
            }
        )

    }

    if( new Date(endDate) < new Date(startDate) ){
        return res.status(400).json({
            "message": "Bad Request", // (or "Validation error" if generated by Sequelize),
            "errors": {
              "endDate": "endDate cannot come before startDate"
            }
          })
    }

    if(checkAvailability[0]){
        return res.status(403).json({
            "message": "Sorry, this spot is already booked for the specified dates",
            "errors": {
              "startDate": "Start date conflicts with an existing booking",
              "endDate": "End date conflicts with an existing booking"
            }
          })
    }

    if(bookingOwner && bookingOwner.dataValues.userId === userId){

        const updateData = req.body
        const updateBooking = await Booking.update(updateData, {
            where: {
                id: bookingId
            }
        })

        const updatedBooking = await Booking.findByPk(bookingId)

        if(!updateBooking){
            return res.status(400).json({
                "message": "Bad Request", // (or "Validation error" if generated by Sequelize),
                "errors": {
                  "endDate": "endDate cannot come before startDate"
                }
              })
        }

        if(updateBooking){
            return res.json(updatedBooking)
        }


    }

})

//---------------------------------------------------------------------


/* Delete a Booking
Delete an existing booking.

Require Authentication: true

Require proper authorization: Booking must belong to the current user or the Spot must belong to the current user */

router.delete('/:bookingId', requireAuth, async (req, res, next) => {

    /*
    const bookingId = req.params.bookingId
    const userId = req.user.id

    const bookingsOwner = await Booking.findByPk(bookingId)

    if(!bookingsOwner){
        return res.status(404).json({
            "message": "Booking couldn't be found"
          })
    }

    if(bookingsOwner.dataValues.userId != userId){
        return res.status(403).json({
            "message": "Forbidden"
          })
    }

    let todaysDate = new Date();
        //todaysDate = todaysDate.toISOString().substring(0, 10)

    if(bookingsOwner && new Date(bookingsOwner.dataValues.startDate) > todaysDate){
        return res.status(403).json({
            "message": "Bookings that have been started can't be deleted"
          })
    }

    await Booking.destroy({
        where: {
            id: bookingId
        }
    })

    return res.json({
        "message": "Successfully deleted"
      })

      */
// second try:



const bookingId = req.params.bookingId

const userId = req.user.id

const booking = await Booking.findAll({
    where: {
        id: bookingId
    }
})

if(!booking[0]){
    return res.status(404).json({
        "message": "Booking couldn't be found"
      })
}

if(booking[0].dataValues.userId != userId){
    return res.status(403).json({
        "message": "Forbidden"
      })
}

const todaysDate = new Date()

const bookingStartDate = new Date(booking[0].dataValues.startDate)

if(todaysDate > bookingStartDate){
    return res.status(403).json({
        "message": "Bookings that have been started can't be deleted"
      })
}

await Booking.destroy({
    where: {
        id: bookingId
    }
})

return res.json({
    "message": "Successfully deleted"
  })

})

//-------------------------------------------------------------------------------




// exports -------------------
module.exports = router;
//----------------------------
